// tapable@2.2.2 downloaded from https://ga.jspm.io/npm:tapable@2.2.2/lib/index.js

import o from"./SyncHook.js";import t from"./SyncBailHook.js";import e from"./Hook.js";import r from"./HookCodeFactory.js";import n from"./AsyncSeriesHook.js";import s from"./AsyncSeriesBailHook.js";import*as a from"util";var c={};const i=e;const l=r;class SyncWaterfallHookCodeFactory extends l{content({onError:o,onResult:t,resultReturns:e,rethrowIfPossible:r}){return this.callTapsSeries({onError:(t,e)=>o(e),onResult:(o,t,e)=>{let r="";r+=`if(${t} !== undefined) {\n`;r+=`${this._args[0]} = ${t};\n`;r+="}\n";r+=e();return r},onDone:()=>t(this._args[0]),doneReturns:e,rethrowIfPossible:r})}}const u=new SyncWaterfallHookCodeFactory;const p=()=>{throw new Error("tapAsync is not supported on a SyncWaterfallHook")};const f=()=>{throw new Error("tapPromise is not supported on a SyncWaterfallHook")};const y=function(o){u.setup(this,o);return u.create(o)};function h(o=[],t=void 0){if(o.length<1)throw new Error("Waterfall hooks must have at least one argument");const e=new i(o,t);e.constructor=h;e.tapAsync=p;e.tapPromise=f;e.compile=y;return e}h.prototype=null;c=h;var k=c;var d={};const H=e;const m=r;class SyncLoopHookCodeFactory extends m{content({onError:o,onDone:t,rethrowIfPossible:e}){return this.callTapsLooping({onError:(t,e)=>o(e),onDone:t,rethrowIfPossible:e})}}const v=new SyncLoopHookCodeFactory;const S=()=>{throw new Error("tapAsync is not supported on a SyncLoopHook")};const w=()=>{throw new Error("tapPromise is not supported on a SyncLoopHook")};const A=function(o){v.setup(this,o);return v.create(o)};function _(o=[],t=void 0){const e=new H(o,t);e.constructor=_;e.tapAsync=S;e.tapPromise=w;e.compile=A;return e}_.prototype=null;d=_;var P=d;var g={};const E=e;const $=r;class AsyncParallelHookCodeFactory extends ${content({onError:o,onDone:t}){return this.callTapsParallel({onError:(t,e,r,n)=>o(e)+n(true),onDone:t})}}const M=new AsyncParallelHookCodeFactory;const D=function(o){M.setup(this,o);return M.create(o)};function C(o=[],t=void 0){const e=new E(o,t);e.constructor=C;e.compile=D;e._call=void 0;e.call=void 0;return e}C.prototype=null;g=C;var F=g;var L={};const W=e;const B=r;class AsyncParallelBailHookCodeFactory extends B{content({onError:o,onResult:t,onDone:e}){let r="";r+=`var _results = new Array(${this.options.taps.length});\n`;r+="var _checkDone = function() {\n";r+="for(var i = 0; i < _results.length; i++) {\n";r+="var item = _results[i];\n";r+="if(item === undefined) return false;\n";r+="if(item.result !== undefined) {\n";r+=t("item.result");r+="return true;\n";r+="}\n";r+="if(item.error) {\n";r+=o("item.error");r+="return true;\n";r+="}\n";r+="}\n";r+="return false;\n";r+="}\n";r+=this.callTapsParallel({onError:(o,t,e,r)=>{let n="";n+=`if(${o} < _results.length && ((_results.length = ${o+1}), (_results[${o}] = { error: ${t} }), _checkDone())) {\n`;n+=r(true);n+="} else {\n";n+=e();n+="}\n";return n},onResult:(o,t,e,r)=>{let n="";n+=`if(${o} < _results.length && (${t} !== undefined && (_results.length = ${o+1}), (_results[${o}] = { result: ${t} }), _checkDone())) {\n`;n+=r(true);n+="} else {\n";n+=e();n+="}\n";return n},onTap:(o,t,e,r)=>{let n="";if(o>0){n+=`if(${o} >= _results.length) {\n`;n+=e();n+="} else {\n"}n+=t();o>0&&(n+="}\n");return n},onDone:e});return r}}const R=new AsyncParallelBailHookCodeFactory;const j=function(o){R.setup(this,o);return R.create(o)};function x(o=[],t=void 0){const e=new W(o,t);e.constructor=x;e.compile=j;e._call=void 0;e.call=void 0;return e}x.prototype=null;L=x;var T=L;var b={};const U=e;const I=r;class AsyncSeriesLoopHookCodeFactory extends I{content({onError:o,onDone:t}){return this.callTapsLooping({onError:(t,e,r,n)=>o(e)+n(true),onDone:t})}}const O=new AsyncSeriesLoopHookCodeFactory;const q=function(o){O.setup(this,o);return O.create(o)};function z(o=[],t=void 0){const e=new U(o,t);e.constructor=z;e.compile=q;e._call=void 0;e.call=void 0;return e}z.prototype=null;b=z;var G=b;var J={};const K=e;const N=r;class AsyncSeriesWaterfallHookCodeFactory extends N{content({onError:o,onResult:t,onDone:e}){return this.callTapsSeries({onError:(t,e,r,n)=>o(e)+n(true),onResult:(o,t,e)=>{let r="";r+=`if(${t} !== undefined) {\n`;r+=`${this._args[0]} = ${t};\n`;r+="}\n";r+=e();return r},onDone:()=>t(this._args[0])})}}const Q=new AsyncSeriesWaterfallHookCodeFactory;const V=function(o){Q.setup(this,o);return Q.create(o)};function X(o=[],t=void 0){if(o.length<1)throw new Error("Waterfall hooks must have at least one argument");const e=new K(o,t);e.constructor=X;e.compile=V;e._call=void 0;e.call=void 0;return e}X.prototype=null;J=X;var Y=J;var Z=a;try{"default"in a&&(Z=a.default)}catch(o){}var oo={};const to=Z;const eo=(o,t)=>t;let ro=class HookMap{constructor(o,t=void 0){this._map=new Map;this.name=t;this._factory=o;this._interceptors=[]}get(o){return this._map.get(o)}for(o){const t=this.get(o);if(t!==void 0)return t;let e=this._factory(o);const r=this._interceptors;for(let t=0;t<r.length;t++)e=r[t].factory(o,e);this._map.set(o,e);return e}intercept(o){this._interceptors.push(Object.assign({factory:eo},o))}};ro.prototype.tap=to.deprecate((function(o,t,e){return this.for(o).tap(t,e)}),"HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");ro.prototype.tapAsync=to.deprecate((function(o,t,e){return this.for(o).tapAsync(t,e)}),"HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");ro.prototype.tapPromise=to.deprecate((function(o,t,e){return this.for(o).tapPromise(t,e)}),"HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");oo=ro;var no=oo;var so={};let ao=class MultiHook{constructor(o,t=void 0){this.hooks=o;this.name=t}tap(o,t){for(const e of this.hooks)e.tap(o,t)}tapAsync(o,t){for(const e of this.hooks)e.tapAsync(o,t)}tapPromise(o,t){for(const e of this.hooks)e.tapPromise(o,t)}isUsed(){for(const o of this.hooks)if(o.isUsed())return true;return false}intercept(o){for(const t of this.hooks)t.intercept(o)}withOptions(o){return new MultiHook(this.hooks.map((t=>t.withOptions(o))),this.name)}};so=ao;var co=so;var io={};io.__esModule=true;io.SyncHook=o;io.SyncBailHook=t;io.SyncWaterfallHook=k;io.SyncLoopHook=P;io.AsyncParallelHook=F;io.AsyncParallelBailHook=T;io.AsyncSeriesHook=n;io.AsyncSeriesBailHook=s;io.AsyncSeriesLoopHook=G;io.AsyncSeriesWaterfallHook=Y;io.HookMap=no;io.MultiHook=co;const lo=io.__esModule,uo=io.SyncHook,po=io.SyncBailHook,fo=io.SyncWaterfallHook,yo=io.SyncLoopHook,ho=io.AsyncParallelHook,ko=io.AsyncParallelBailHook,Ho=io.AsyncSeriesHook,mo=io.AsyncSeriesBailHook,vo=io.AsyncSeriesLoopHook,So=io.AsyncSeriesWaterfallHook,wo=io.HookMap,Ao=io.MultiHook;export{ko as AsyncParallelBailHook,ho as AsyncParallelHook,mo as AsyncSeriesBailHook,Ho as AsyncSeriesHook,vo as AsyncSeriesLoopHook,So as AsyncSeriesWaterfallHook,wo as HookMap,Ao as MultiHook,po as SyncBailHook,uo as SyncHook,yo as SyncLoopHook,fo as SyncWaterfallHook,lo as __esModule,io as default};

